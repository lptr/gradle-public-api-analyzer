/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.example;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.MultimapBuilder;
import com.google.common.collect.SetMultimap;
import com.ibm.wala.classLoader.BinaryDirectoryTreeModule;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.core.util.config.AnalysisScopeReader;
import com.ibm.wala.ipa.callgraph.AnalysisScope;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.ClassHierarchyFactory;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.TypeReference;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.jar.JarFile;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class App {
    private static final ImmutableList<Pattern> publicApiPackages = Stream.of(
            "org/gradle/[^/]*",
            "org/gradle/api/.*",
            "org/gradle/authentication/.*",
            "org/gradle/build/.*",
            "org/gradle/buildconfiguration/.*",
            "org/gradle/buildinit/.*",
            "org/gradle/caching/.*",
            "org/gradle/concurrent/.*",
            "org/gradle/deployment/.*",
            "org/gradle/external/javadoc/.*",
            "org/gradle/ide/.*",
            "org/gradle/ivy/.*",
            "org/gradle/jvm/.*",
            "org/gradle/language/.*",
            "org/gradle/maven/.*",
            "org/gradle/nativeplatform/.*",
            "org/gradle/normalization/.*",
            "org/gradle/platform/.*",
            "org/gradle/plugin/devel/.*",
            "org/gradle/plugin/use/[^/]*",
            "org/gradle/plugin/management/[^/]*",
            "org/gradle/plugins/.*",
            "org/gradle/process/.*",
            "org/gradle/testfixtures/.*",
            "org/gradle/testing/jacoco/.*",
            "org/gradle/tooling/.*",
            "org/gradle/swiftpm/.*",
            "org/gradle/model/.*",
            "org/gradle/testkit/.*",
            "org/gradle/testing/.*",
            "org/gradle/vcs/.*",
            "org/gradle/work/.*",
            "org/gradle/workers/.*",
            "org/gradle/util/.*"
        )
        .map(Pattern::compile)
        .collect(ImmutableList.toImmutableList());

    public static void main(String[] args) throws IOException, ClassHierarchyException {
        args = new String[]{
            "/Users/lptr/.gradle/caches/8.8-rc-1/generated-gradle-jars/gradle-api-8.8-rc-1.jar"
        };
        ImmutableList<Path> classpath = Arrays.stream(args)
            .map(Paths::get)
            .collect(ImmutableList.toImmutableList());
        AnalysisScope scope = createScope(classpath);
        ClassHierarchy hierarchy = ClassHierarchyFactory.make(scope);
        int publicMethodCount = 0;
        ListMultimap<String, IClass> packages = MultimapBuilder.treeKeys().arrayListValues().build();
        Comparator<IClass> classComparator = Comparator.<IClass, String>comparing(clazz -> clazz.getName().getClassName().toString());
        ListMultimap<IClass, IMethod> publicMethods = MultimapBuilder.treeKeys(classComparator).arrayListValues().build();
        SetMultimap<IClass, String> properties = MultimapBuilder.treeKeys(classComparator).treeSetValues().build();
        for (IClass iClass : hierarchy) {
            // Skip non-public types
            if (!iClass.isPublic()) {
                continue;
            }
            // Skip anonymous inner classes
            if (iClass.getName().getClassName().toString().contains("$")) {
                continue;
            }
            String pkgName = String.valueOf(iClass.getName().getPackage());
            if (publicApiPackages.stream().noneMatch(pattern -> pattern.matcher(pkgName).matches())) {
                continue;
            }
            if (pkgName.contains("/internal/") || pkgName.endsWith("/internal")) {
                continue;
            }

            packages.put(pkgName, iClass);
            for (IMethod declaredMethod : iClass.getDeclaredMethods()) {
                if (!declaredMethod.isPublic()) {
                    continue;
                }
                publicMethodCount++;
                System.out.println(declaredMethod.getSignature());
                publicMethods.put(iClass, declaredMethod);

                if (declaredMethod.isInit() || declaredMethod.isClinit()) {
                    continue;
                }

                toPropertyName(declaredMethod)
                    .ifPresent(propertyName -> properties.put(iClass, propertyName));
            }
        }
        System.out.println("# Statistics");
        System.out.println("Public method count: " + publicMethodCount);
        System.out.println("Properties count: " + properties.size());

        System.out.println("# Weird setters");
        properties.forEach((iClass, propertyName) -> {
            // TODO Should this filter all methods? Should we look at all child types, too?
            publicMethods.get(iClass).stream()
                .filter(IMethod::isPublic)
                .filter(Predicate.not(IMethod::isStatic))
                .filter(method -> method.getNumberOfParameters() == 2)
                .filter(method -> method.getName().toString().equals(propertyName))
                .filter(method -> {
                    TypeReference parameterType = method.getParameterType(1);
                    return !parameterType.getName().toString().equals("Lgroovy/lang/Closure")
                        && !parameterType.getName().toString().equals("Lorg/gradle/api/Action");
                })
                .findFirst()
                .ifPresent(weirdSetter -> System.out.printf("- `%s`%n", toSimpleSignature(weirdSetter)));
        });
    }

    private static String toSimpleSignature(IMethod method) {
        // Get the class name
        String className = toSimpleName(method.getDeclaringClass().getReference());

        // Get the method name
        String methodName = method.getName().toString();

        // Get the parameter types
        String parameterTypes = Stream.iterate(method.isStatic() ? 0 : 1, i -> i < method.getNumberOfParameters(), i -> i + 1)
            .map(method::getParameterType)
            .map(App::toSimpleName)
            .collect(Collectors.joining(", "));

        // Get the return type
        String returnType = toSimpleName(method.getReturnType());

        return String.format("%s %s.%s(%s)", returnType, className, methodName, parameterTypes);
    }

    private static String toSimpleName(TypeReference typeReference) {
        String simpleName = toSimpleTypeName(typeReference);
        if (typeReference.isArrayType()) {
            return toSimpleName(typeReference.getArrayElementType()) + "[]";
        } else {
            return simpleName;
        }
    }

    private static String toSimpleTypeName(TypeReference typeReference) {
        if (typeReference.equals(TypeReference.Void)) {
            return "void";
        }
        if (typeReference.isPrimitiveType()) {
            if (typeReference.equals(TypeReference.Byte)) {
                return "byte";
            }
            if (typeReference.equals(TypeReference.Char)) {
                return "char";
            }
            if (typeReference.equals(TypeReference.Double)) {
                return "double";
            }
            if (typeReference.equals(TypeReference.Float)) {
                return "float";
            }
            if (typeReference.equals(TypeReference.Int)) {
                return "int";
            }
            if (typeReference.equals(TypeReference.Long)) {
                return "long";
            }
            if (typeReference.equals(TypeReference.Short)) {
                return "short";
            }
            if (typeReference.equals(TypeReference.Boolean)) {
                return "boolean";
            }
        }
        String name = typeReference.getName().toString();
        // Remove package part if present
        if (name.contains("/")) {
            name = name.substring(name.lastIndexOf('/') + 1);
        }
        return name.replace(';', ' ').trim();
    }

    private static Optional<String> toPropertyName(IMethod method) {
        String methodName = method.getName().toString();
        if (method.isStatic()) {
            return Optional.empty();
        }
        if (method.getNumberOfParameters() == 1 && !method.getReturnType().equals(TypeReference.Void)) {
            if (methodName.startsWith("get") && methodName.length() > 3) {
                return Optional.of(Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4));
            }
            if (methodName.startsWith("is") && methodName.length() > 2) {
                return Optional.of(Character.toLowerCase(methodName.charAt(2)) + methodName.substring(3));
            }
        }
        if (method.getNumberOfParameters() == 2 && methodName.startsWith("set") && methodName.length() > 3) {
            return Optional.of(Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4));
        }
        return Optional.empty();
    }

    private static AnalysisScope createScope(Collection<Path> classpath) throws IOException {
        AnalysisScope scope = AnalysisScopeReader.instance.makePrimordialScope(null);
        classpath.forEach(path -> addToScope(scope, path));
        return scope;
    }

    private static void addToScope(AnalysisScope scope, Path path) {
        ClassLoaderReference loader = scope.getLoader(AnalysisScope.APPLICATION);
        if (Files.isRegularFile(path)) {
            try {
                JarFile jar = new JarFile(path.toFile(), false);
                scope.addToScope(loader, jar);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        } else {
            scope.addToScope(loader, new BinaryDirectoryTreeModule(path.toFile()));
        }
    }
}
