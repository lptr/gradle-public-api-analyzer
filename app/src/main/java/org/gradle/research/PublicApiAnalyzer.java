/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.gradle.research;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Maps;
import com.google.common.collect.MultimapBuilder;
import com.ibm.wala.classLoader.BinaryDirectoryTreeModule;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.core.util.config.AnalysisScopeReader;
import com.ibm.wala.ipa.callgraph.AnalysisScope;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.ClassHierarchyFactory;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.TypeReference;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.TreeMap;
import java.util.function.Predicate;
import java.util.jar.JarFile;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class PublicApiAnalyzer {
    private static final ImmutableList<Pattern> publicApiPackages = Stream.of(
            "org/gradle/[^/]*",
            "org/gradle/api/.*",
            "org/gradle/authentication/.*",
            "org/gradle/build/.*",
            "org/gradle/buildconfiguration/.*",
            "org/gradle/buildinit/.*",
            "org/gradle/caching/.*",
            "org/gradle/concurrent/.*",
            "org/gradle/deployment/.*",
            "org/gradle/external/javadoc/.*",
            "org/gradle/ide/.*",
            "org/gradle/ivy/.*",
            "org/gradle/jvm/.*",
            "org/gradle/language/.*",
            "org/gradle/maven/.*",
            "org/gradle/nativeplatform/.*",
            "org/gradle/normalization/.*",
            "org/gradle/platform/.*",
            "org/gradle/plugin/devel/.*",
            "org/gradle/plugin/use/[^/]*",
            "org/gradle/plugin/management/[^/]*",
            "org/gradle/plugins/.*",
            "org/gradle/process/.*",
            "org/gradle/testfixtures/.*",
            "org/gradle/testing/jacoco/.*",
            "org/gradle/tooling/.*",
            "org/gradle/swiftpm/.*",
            "org/gradle/model/.*",
            "org/gradle/testkit/.*",
            "org/gradle/testing/.*",
            "org/gradle/vcs/.*",
            "org/gradle/work/.*",
            "org/gradle/workers/.*",
            "org/gradle/util/.*"
        )
        .map(Pattern::compile)
        .collect(ImmutableList.toImmutableList());

    public static void main(String[] args) throws IOException, ClassHierarchyException {
        ImmutableList<Path> classpath = Arrays.stream(args)
            .map(Paths::get)
            .collect(ImmutableList.toImmutableList());
        AnalysisScope scope = createScope(classpath);
        ClassHierarchy hierarchy = ClassHierarchyFactory.make(scope);
        ListMultimap<String, IClass> packagesToTypes = MultimapBuilder.treeKeys().arrayListValues().build();
        Comparator<IClass> classComparator = Comparator.<IClass, String>comparing(clazz -> clazz.getName().getClassName().toString());
        ListMultimap<IClass, IMethod> typesToMethods = MultimapBuilder.treeKeys(classComparator).arrayListValues().build();
        Map<IClass, Map<String, Property>> typesToProperties = Maps.newTreeMap(classComparator);
        for (IClass iClass : hierarchy) {
            // Skip non-public types
            if (!iClass.isPublic()) {
                continue;
            }
            // Skip anonymous inner classes
            if (iClass.getName().getClassName().toString().contains("$")) {
                continue;
            }
            String pkgName = String.valueOf(iClass.getName().getPackage());
            if (publicApiPackages.stream().noneMatch(pattern -> pattern.matcher(pkgName).matches())) {
                continue;
            }
            if (pkgName.contains("/internal/") || pkgName.endsWith("/internal")) {
                continue;
            }

            packagesToTypes.put(pkgName, iClass);
            for (IMethod declaredMethod : iClass.getDeclaredMethods()) {
                if (!declaredMethod.isPublic()) {
                    continue;
                }
                typesToMethods.put(iClass, declaredMethod);

                if (declaredMethod.isInit() || declaredMethod.isClinit()) {
                    continue;
                }

                PropertyMethod.from(declaredMethod)
                    .ifPresent(propertyMethod -> {
                        typesToProperties.computeIfAbsent(iClass, __ -> new TreeMap<>())
                            .computeIfAbsent(propertyMethod.propertyName(), __ -> new Property())
                            .addPropertyMethod(propertyMethod);
                    });
            }
        }
        printHeader("Public API statistics");
        System.out.println("- Packages: " + packagesToTypes.keySet().size());
        System.out.println("- Types: " + packagesToTypes.size());
        System.out.println("- Methods: " + typesToMethods.size());
        System.out.println("- Properties: " + typesToProperties.values().stream().mapToInt(Map::size).sum());

        printHeader("Setter-only properties");
        forEachProperty(typesToProperties, (type, propertyName, property) -> {
            if (property.getter == null) {
                System.out.printf("- `%s.%s`%n", toSimpleName(type.getReference()), propertyName);
            }
        });

        var propertiesWithInconsistentSetters = new ArrayList<String>();
        var propertiesWithAdditionalSetters = new ArrayList<String>();
        forEachProperty(typesToProperties, (type, propertyName, property) -> {
            // Ignore properties without a getter
            if (property.getter == null) {
                return;
            }
            ImmutableSet<TypeReference> types = property.collectTypes();
            if (types.size() != 1) {
                String inconsistentGetterDescription = String.format("- `%s` (setter: %s)",
                    toSimpleSignature(property.getter),
                    types.stream().filter(Predicate.not(property.getter.getReturnType()::equals))
                        .map(PublicApiAnalyzer::toSimpleName)
                        .map("`%s`"::formatted)
                        .collect(Collectors.joining(", ")));

                property.matchingGetterAndSetterType()
                    .ifPresentOrElse(
                        matchingType -> propertiesWithAdditionalSetters.add(inconsistentGetterDescription),
                        () -> propertiesWithInconsistentSetters.add(inconsistentGetterDescription)
                    );
            }
        });

        printHeader("Properties with inconsistent getter/setter types");
        propertiesWithInconsistentSetters.forEach(System.out::println);

        printHeader("Properties with consistent getter/setter types, but with additional setter types");
        propertiesWithAdditionalSetters.forEach(System.out::println);

        printHeader("Properties with `propertyName()` setters");
        forEachProperty(typesToProperties, (type, propertyName, property) -> {
            typesToMethods.get(type).stream()
                .filter(Predicate.not(IMethod::isStatic))
                .filter(method -> method.getNumberOfParameters() == 2)
                .filter(method -> method.getName().toString().equals(propertyName))
                .filter(method -> {
                    TypeReference parameterType = method.getParameterType(1);
                    return !parameterType.getName().toString().equals("Lgroovy/lang/Closure")
                           && !parameterType.getName().toString().equals("Lorg/gradle/api/Action");
                })
                .findFirst()
                .ifPresent(weirdSetter -> System.out.printf("- `%s`%n", toSimpleSignature(weirdSetter)));
        });
    }

    private static void printHeader(String header) {
        System.out.println();
        System.out.println("# " + header);
        System.out.println();
    }

    private static void forEachProperty(Map<IClass, Map<String, Property>> properties, TriConsumer<IClass, String, Property> consumer) {
        properties.forEach((iClass, classProperties) -> {
            classProperties.forEach((propertyName, property) -> {
                consumer.accept(iClass, propertyName, property);
            });
        });
    }

    private interface TriConsumer<T, U, V> {
        void accept(T t, U u, V v);
    }

    private static String toSimpleSignature(IMethod method) {
        // Get the class name
        String className = toSimpleName(method.getDeclaringClass().getReference());

        // Get the method name
        String methodName = method.getName().toString();

        // Get the parameter types
        String parameterTypes = Stream.iterate(method.isStatic() ? 0 : 1, i -> i < method.getNumberOfParameters(), i -> i + 1)
            .map(method::getParameterType)
            .map(PublicApiAnalyzer::toSimpleName)
            .collect(Collectors.joining(", "));

        // Get the return type
        String returnType = toSimpleName(method.getReturnType());

        return String.format("%s %s.%s(%s)", returnType, className, methodName, parameterTypes);
    }

    private static String toSimpleName(TypeReference typeReference) {
        String simpleName = toSimpleTypeName(typeReference);
        if (typeReference.isArrayType()) {
            return toSimpleName(typeReference.getArrayElementType()) + "[]";
        } else {
            return simpleName;
        }
    }

    private static String toSimpleTypeName(TypeReference typeReference) {
        if (typeReference.equals(TypeReference.Void)) {
            return "void";
        }
        if (typeReference.isPrimitiveType()) {
            if (typeReference.equals(TypeReference.Byte)) {
                return "byte";
            }
            if (typeReference.equals(TypeReference.Char)) {
                return "char";
            }
            if (typeReference.equals(TypeReference.Double)) {
                return "double";
            }
            if (typeReference.equals(TypeReference.Float)) {
                return "float";
            }
            if (typeReference.equals(TypeReference.Int)) {
                return "int";
            }
            if (typeReference.equals(TypeReference.Long)) {
                return "long";
            }
            if (typeReference.equals(TypeReference.Short)) {
                return "short";
            }
            if (typeReference.equals(TypeReference.Boolean)) {
                return "boolean";
            }
        }
        String name = typeReference.getName().toString();
        // Remove package part if present
        if (name.contains("/")) {
            name = name.substring(name.lastIndexOf('/') + 1);
        }
        return name.replace(';', ' ').trim();
    }

    private sealed interface PropertyMethod {
        String propertyName();

        static Optional<PropertyMethod> from(IMethod method) {
            if (method.isStatic()) {
                return Optional.empty();
            }
            String methodName = method.getName().toString();
            if (method.getNumberOfParameters() == 1 && !method.getReturnType().equals(TypeReference.Void)) {
                if (methodName.startsWith("get") && methodName.length() > 3) {
                    return Optional.of(new Getter(Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4), method));
                }
                if (methodName.startsWith("is") && methodName.length() > 2) {
                    return Optional.of(new Getter(Character.toLowerCase(methodName.charAt(2)) + methodName.substring(3), method));
                }
            }
            if (method.getNumberOfParameters() == 2 && methodName.startsWith("set") && methodName.length() > 3) {
                return Optional.of(new Setter(Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4), method));
            }
            return Optional.empty();
        }
    }

    private record Getter(String propertyName, IMethod method) implements PropertyMethod {
    }

    private record Setter(String propertyName, IMethod method) implements PropertyMethod {
    }

    private static class Property {
        private IMethod getter;
        private final List<IMethod> setters = new ArrayList<>();

        public void addPropertyMethod(PropertyMethod propertyMethod) {
            switch (propertyMethod) {
                case Getter getterMethod -> this.getter = getterMethod.method();
                case Setter setterMethod -> this.setters.add(setterMethod.method());
            }
        }

        public ImmutableSet<TypeReference> collectTypes() {
            return Stream.concat(
                    Stream.ofNullable(getter)
                        .map(IMethod::getReturnType),
                    setters.stream()
                        .map(method -> method.getParameterType(1))
                )
                .collect(ImmutableSet.toImmutableSet());
        }

        public Optional<TypeReference> matchingGetterAndSetterType() {
            if (getter == null) {
                return Optional.empty();
            }
            TypeReference getterType = getter.getReturnType();
            return setters.stream()
                .map(method -> method.getParameterType(1))
                .filter(setterType -> setterType.equals(getterType))
                .findFirst();
        }
    }

    private static AnalysisScope createScope(Collection<Path> classpath) throws IOException {
        AnalysisScope scope = AnalysisScopeReader.instance.makePrimordialScope(null);
        classpath.forEach(path -> addToScope(scope, path));
        return scope;
    }

    private static void addToScope(AnalysisScope scope, Path path) {
        ClassLoaderReference loader = scope.getLoader(AnalysisScope.APPLICATION);
        if (Files.isRegularFile(path)) {
            try {
                JarFile jar = new JarFile(path.toFile(), false);
                scope.addToScope(loader, jar);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        } else {
            scope.addToScope(loader, new BinaryDirectoryTreeModule(path.toFile()));
        }
    }
}
